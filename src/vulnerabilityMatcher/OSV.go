package matcher

import (
	"log"
	"strings"
	"sync"

	ecosystemTypes "github.com/CodeClarityCE/plugin-sca-vuln-finder/src/ecosystemAnalyzer/types"
	sbomTypes "github.com/CodeClarityCE/plugin-sbom-javascript/src/types/sbom/js"
	vulnerabilityFinder "github.com/CodeClarityCE/plugin-sca-vuln-finder/src/types"
	osvMatcher "github.com/CodeClarityCE/plugin-sca-vuln-finder/src/vulnerabilityMatcher/osv"
	semver "github.com/CodeClarityCE/utility-node-semver"
	"github.com/package-url/packageurl-go"
	"github.com/uptrace/bun"

	"github.com/CodeClarityCE/plugin-sca-vuln-finder/src/repository/osv"
)

// getPackageURLType maps our internal ecosystem types to packageurl types
func (vm VulnerabilityMatcher) getPackageURLType() string {
	if len(vm.Ecosystems) == 0 {
		return "npm" // default fallback
	}
	
	switch vm.Ecosystems[0] {
	case ecosystemTypes.NODEJS_OR_JS:
		return "npm"
	case ecosystemTypes.PHP:
		return "composer"
	case ecosystemTypes.PYTHON:
		return "pypi" 
	case ecosystemTypes.RUBY:
		return "gem"
	case ecosystemTypes.RUST:
		return "cargo"
	case ecosystemTypes.JAVA:
		return "maven"
	case ecosystemTypes.DOTNET:
		return "nuget"
	case ecosystemTypes.GO:
		return "golang"
	default:
		return "npm" // fallback
	}
}

func (vm VulnerabilityMatcher) getOSVVulnerabilities(dependencies map[string]map[string]sbomTypes.Versions, knowledge *bun.DB) []vulnerabilityFinder.OSVVulnerability {

	osvMatches := []vulnerabilityFinder.OSVVulnerability{}

	var wg sync.WaitGroup
	maxGoroutines := 20
	guard := make(chan struct{}, maxGoroutines)
	mutex := sync.Mutex{}

	for dependency_name, dependency := range dependencies {
		wg.Add(1)
		guard <- struct{}{}
		go func(wg *sync.WaitGroup) {
			defer wg.Done()
			for version_name, version := range dependency {
				if !version.Direct && !version.Transitive {
					continue
				}

				splitted_name := strings.Split(dependency_name, "/")
				var namespace, name string

				if len(splitted_name) == 1 {
					name = splitted_name[0]
				} else {
					namespace = splitted_name[0]
					name = splitted_name[1]
				}

				packageType := vm.getPackageURLType()
				purl := packageurl.NewPackageURL(packageType, namespace, name, "", packageurl.Qualifiers{}, "")
				osvReports, err := osv.GetAllOSVReportsForPurl(purl.ToString(), knowledge)
				if err != nil {
					log.Println("Failed to fetch osv reports for dep: " + dependency_name)
					continue
				}

				for _, osvReport := range osvReports {
					affectedUniform := osvMatcher.NormalizeAffectedVersions(dependency_name, osvReport.Affected, vm.PackageRepository, knowledge)
					semver, err := semver.ParseSemver(version_name)
					if err == nil {
						mutex.Lock()
						osvMatches = append(osvMatches, vulnerabilityFinder.OSVVulnerability{
							Vulnerability: osvReport,
							Dependency: vulnerabilityFinder.Dependency{
								Name:        dependency_name,
								VersionInfo: version,
								Semver:      semver,
							},
							AffectedInfo: affectedUniform,
						})
						mutex.Unlock()
					}
				}
			}
			<-guard
		}(&wg)
	}

	filteredMatches := []vulnerabilityFinder.OSVVulnerability{}

	for _, osvMatch := range osvMatches {
		matches, evidenceVulnerable := MatchRange(osvMatch.AffectedInfo, osvMatch.Dependency.Semver)
		if matches {
			osvMatch.VulnerableEvidenceType = vulnerabilityFinder.VULNERABLE_EVIDENCE_RANGE
			osvMatch.VulnerableEvidenceRange = evidenceVulnerable
			osvMatch.Vulnerable = true
			filteredMatches = append(filteredMatches, osvMatch)
			continue
		}

		matches, evidenceVulnerableExact := MatchExact(osvMatch.AffectedInfo, osvMatch.Dependency.Semver)
		if matches {
			osvMatch.VulnerableEvidenceType = vulnerabilityFinder.VULNERABLE_EVIDENCE_EXACT
			osvMatch.VulnerableEvidenceExact = evidenceVulnerableExact
			osvMatch.Vulnerable = true
			filteredMatches = append(filteredMatches, osvMatch)
			continue
		}

		matches, evidenceVulnerableUniversal := MatchUniversal(osvMatch.AffectedInfo, osvMatch.Dependency.Semver)
		if matches {
			osvMatch.VulnerableEvidenceType = vulnerabilityFinder.VULNERABLE_EVIDENCE_UNIVERSAL
			osvMatch.VulnerableEvidenceUniversal = evidenceVulnerableUniversal
			osvMatch.Vulnerable = true
			filteredMatches = append(filteredMatches, osvMatch)
			continue
		}
	}

	return filteredMatches
}
