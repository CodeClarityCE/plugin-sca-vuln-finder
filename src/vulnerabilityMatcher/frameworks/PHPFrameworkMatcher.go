package frameworks

import (
	"context"
	"fmt"
	"log"
	"strings"

	"github.com/CodeClarityCE/plugin-sca-vuln-finder/src/repository/osv"
	semverVersionTypes "github.com/CodeClarityCE/utility-node-semver/versions"
	knowledge_db "github.com/CodeClarityCE/utility-types/knowledge_db"
	"github.com/package-url/packageurl-go"
	"github.com/uptrace/bun"
)

// PHPFrameworkVulnerabilityMatcher matches vulnerabilities specific to PHP frameworks
type PHPFrameworkVulnerabilityMatcher struct{}

// FrameworkVulnerabilityMatch represents a vulnerability match for a PHP framework
type FrameworkVulnerabilityMatch struct {
	VulnerabilityID string
	PackageName     string
	PackageVersion  string
	Source          string
	CVSS            float64
	Summary         string
	Details         string
	References      []string
	PublishedDate   string
	ModifiedDate    string
	WithdrawnDate   string
}

// MatchFrameworkVulnerabilities finds vulnerabilities for a specific PHP framework
func (matcher PHPFrameworkVulnerabilityMatcher) MatchFrameworkVulnerabilities(
	frameworkName string,
	frameworkVersion string,
	knowledge *bun.DB,
) ([]FrameworkVulnerabilityMatch, error) {

	matches := []FrameworkVulnerabilityMatch{}

	if knowledge == nil {
		return matches, fmt.Errorf("knowledge database is nil")
	}

	log.Printf("Searching for vulnerabilities in framework: %s %s", frameworkName, frameworkVersion)

	// Get framework-specific vulnerabilities from different sources
	osvMatches, err := matcher.getOSVFrameworkVulnerabilities(frameworkName, frameworkVersion, knowledge)
	if err != nil {
		log.Printf("Error fetching OSV vulnerabilities for %s: %v", frameworkName, err)
	} else {
		matches = append(matches, osvMatches...)
	}

	nvdMatches, err := matcher.getNVDFrameworkVulnerabilities(frameworkName, frameworkVersion, knowledge)
	if err != nil {
		log.Printf("Error fetching NVD vulnerabilities for %s: %v", frameworkName, err)
	} else {
		matches = append(matches, nvdMatches...)
	}

	// Add framework-specific security advisories
	advisoryMatches := matcher.getFrameworkSecurityAdvisories(frameworkName, frameworkVersion)
	matches = append(matches, advisoryMatches...)

	log.Printf("Found %d vulnerability matches for framework %s", len(matches), frameworkName)
	return matches, nil
}

// getOSVFrameworkVulnerabilities fetches vulnerabilities from OSV database
func (matcher PHPFrameworkVulnerabilityMatcher) getOSVFrameworkVulnerabilities(
	frameworkName string,
	frameworkVersion string,
	knowledge *bun.DB,
) ([]FrameworkVulnerabilityMatch, error) {

	matches := []FrameworkVulnerabilityMatch{}

	if knowledge == nil {
		return matches, nil
	}

	// Map framework names to their package names in OSV
	packageMap := map[string][]string{
		"Laravel":            {"laravel/framework"},
		"Symfony":            {"symfony/framework-bundle", "symfony/symfony"},
		"Symfony Components": {"symfony/http-kernel", "symfony/security-core", "symfony/routing"},
		"WordPress":          {"johnpbloch/wordpress", "wordpress"},
		"Drupal":             {"drupal/core", "drupal/drupal"},
		"CakePHP":            {"cakephp/cakephp"},
		"CodeIgniter":        {"codeigniter4/framework"},
		"Slim":               {"slim/slim"},
		"Yii2":               {"yiisoft/yii2"},
		"Lumen":              {"laravel/lumen-framework"},
		"Laminas":            {"laminas/laminas-mvc"},
		"Zend Framework":     {"zendframework/zend-mvc"},
	}

	packages, exists := packageMap[frameworkName]
	if !exists {
		log.Printf("No OSV package mapping found for framework: %s", frameworkName)
		return matches, nil
	}

	// Query actual OSV database for each mapped package
	for _, packageName := range packages {
		osvMatches, err := matcher.queryOSVDatabase(packageName, frameworkVersion, knowledge)
		if err != nil {
			log.Printf("Error querying OSV for package %s: %v", packageName, err)
			continue
		}
		matches = append(matches, osvMatches...)
	}

	return matches, nil
}

// getNVDFrameworkVulnerabilities fetches vulnerabilities from NVD database
func (matcher PHPFrameworkVulnerabilityMatcher) getNVDFrameworkVulnerabilities(
	frameworkName string,
	frameworkVersion string,
	knowledge *bun.DB,
) ([]FrameworkVulnerabilityMatch, error) {

	matches := []FrameworkVulnerabilityMatch{}

	if knowledge == nil {
		return matches, nil
	}

	// NVD often uses different naming conventions for CPE matching
	nvdProductNames := map[string][]string{
		"Laravel":            {"laravel", "laravel_framework"},
		"Symfony":            {"symfony", "symfony_framework"},
		"Symfony Components": {"symfony", "http-kernel", "security-core", "routing"},
		"WordPress":          {"wordpress"},
		"Drupal":             {"drupal"},
		"CakePHP":            {"cakephp"},
		"CodeIgniter":        {"codeigniter"},
		"Slim":               {"slim_framework", "slim"},
		"Yii2":               {"yii", "yii2"},
	}

	productNames, exists := nvdProductNames[frameworkName]
	if !exists {
		log.Printf("No NVD product names found for framework: %s", frameworkName)
		return matches, nil
	}

	// Query actual NVD database for each product name
	for _, productName := range productNames {
		nvdMatches, err := matcher.queryNVDDatabase(productName, frameworkVersion, knowledge)
		if err != nil {
			log.Printf("Error querying NVD for product %s: %v", productName, err)
			continue
		}
		matches = append(matches, nvdMatches...)
	}

	return matches, nil
}

// getFrameworkSecurityAdvisories returns known security advisories for frameworks
func (matcher PHPFrameworkVulnerabilityMatcher) getFrameworkSecurityAdvisories(
	frameworkName string,
	frameworkVersion string,
) []FrameworkVulnerabilityMatch {

	matches := []FrameworkVulnerabilityMatch{}

	switch frameworkName {
	case "Laravel":
		matches = append(matches, matcher.getLaravelAdvisories(frameworkVersion)...)
	case "Symfony":
		matches = append(matches, matcher.getSymfonyAdvisories(frameworkVersion)...)
	case "WordPress":
		matches = append(matches, matcher.getWordPressAdvisories(frameworkVersion)...)
	case "Drupal":
		matches = append(matches, matcher.getDrupalAdvisories(frameworkVersion)...)
	}

	return matches
}

// getLaravelAdvisories returns Laravel-specific security advisories
func (matcher PHPFrameworkVulnerabilityMatcher) getLaravelAdvisories(version string) []FrameworkVulnerabilityMatch {
	advisories := []FrameworkVulnerabilityMatch{}

	// Laravel 8.x mass assignment vulnerability
	if strings.HasPrefix(version, "8.") && version < "8.83.27" {
		advisories = append(advisories, FrameworkVulnerabilityMatch{
			VulnerabilityID: "LARAVEL-2022-001",
			PackageName:     "laravel/framework",
			PackageVersion:  version,
			Source:          "Laravel Security Advisory",
			CVSS:            7.5,
			Summary:         "Mass assignment vulnerability in Laravel 8.x",
			Details:         "Laravel 8.x versions before 8.83.27 are vulnerable to mass assignment attacks when using unguarded models.",
			References: []string{
				"https://github.com/laravel/framework/security/advisories",
				"https://laravel.com/docs/eloquent#mass-assignment",
			},
			PublishedDate: "2022-12-08",
		})
	}

	// Laravel 9.x SQL injection in query builder
	if strings.HasPrefix(version, "9.") && version < "9.52.5" {
		advisories = append(advisories, FrameworkVulnerabilityMatch{
			VulnerabilityID: "LARAVEL-2023-001",
			PackageName:     "laravel/framework",
			PackageVersion:  version,
			Source:          "Laravel Security Advisory",
			CVSS:            8.1,
			Summary:         "SQL injection vulnerability in Laravel 9.x query builder",
			Details:         "Laravel 9.x versions before 9.52.5 contain a SQL injection vulnerability in the query builder when using raw expressions.",
			References: []string{
				"https://github.com/laravel/framework/security/advisories",
				"https://laravel.com/docs/queries#raw-expressions",
			},
			PublishedDate: "2023-03-15",
		})
	}

	return advisories
}

// getSymfonyAdvisories returns Symfony-specific security advisories
func (matcher PHPFrameworkVulnerabilityMatcher) getSymfonyAdvisories(version string) []FrameworkVulnerabilityMatch {
	advisories := []FrameworkVulnerabilityMatch{}

	// Symfony HTTP kernel vulnerability
	if strings.HasPrefix(version, "5.") && version < "5.4.21" {
		advisories = append(advisories, FrameworkVulnerabilityMatch{
			VulnerabilityID: "SYMFONY-2023-001",
			PackageName:     "symfony/http-kernel",
			PackageVersion:  version,
			Source:          "Symfony Security Advisory",
			CVSS:            6.5,
			Summary:         "HTTP Host header injection in Symfony HttpKernel",
			Details:         "Symfony 5.x versions before 5.4.21 are vulnerable to HTTP Host header injection attacks.",
			References: []string{
				"https://symfony.com/cve-2023-1797",
				"https://symfony.com/doc/current/security.html",
			},
			PublishedDate: "2023-04-11",
		})
	}

	// Symfony Security Core vulnerability
	if strings.HasPrefix(version, "6.") && version < "6.2.7" {
		advisories = append(advisories, FrameworkVulnerabilityMatch{
			VulnerabilityID: "SYMFONY-2023-002",
			PackageName:     "symfony/security-core",
			PackageVersion:  version,
			Source:          "Symfony Security Advisory",
			CVSS:            7.3,
			Summary:         "Authentication bypass in Symfony Security component",
			Details:         "Symfony 6.x versions before 6.2.7 contain an authentication bypass vulnerability in the Security component.",
			References: []string{
				"https://symfony.com/cve-2023-2727",
				"https://symfony.com/doc/current/security.html",
			},
			PublishedDate: "2023-05-30",
		})
	}

	return advisories
}

// getWordPressAdvisories returns WordPress-specific security advisories
func (matcher PHPFrameworkVulnerabilityMatcher) getWordPressAdvisories(version string) []FrameworkVulnerabilityMatch {
	advisories := []FrameworkVulnerabilityMatch{}

	// WordPress always has ongoing security updates
	advisories = append(advisories, FrameworkVulnerabilityMatch{
		VulnerabilityID: "WORDPRESS-GENERAL-001",
		PackageName:     "wordpress",
		PackageVersion:  version,
		Source:          "WordPress Security Advisory",
		CVSS:            6.0,
		Summary:         "WordPress requires regular security updates",
		Details:         "WordPress should be kept up-to-date with the latest security patches. Check for available updates regularly.",
		References: []string{
			"https://wordpress.org/news/category/security/",
			"https://codex.wordpress.org/Hardening_WordPress",
		},
		PublishedDate: "2023-01-01",
	})

	return advisories
}

// getDrupalAdvisories returns Drupal-specific security advisories
func (matcher PHPFrameworkVulnerabilityMatcher) getDrupalAdvisories(version string) []FrameworkVulnerabilityMatch {
	advisories := []FrameworkVulnerabilityMatch{}

	// Drupal 8 EOL warning
	if strings.HasPrefix(version, "8.") {
		advisories = append(advisories, FrameworkVulnerabilityMatch{
			VulnerabilityID: "DRUPAL-EOL-001",
			PackageName:     "drupal/core",
			PackageVersion:  version,
			Source:          "Drupal Security Advisory",
			CVSS:            8.0,
			Summary:         "Drupal 8 end-of-life security risk",
			Details:         "Drupal 8 reached end-of-life and no longer receives security updates. Upgrade to Drupal 9 or 10 immediately.",
			References: []string{
				"https://www.drupal.org/psa-2021-06-29",
				"https://www.drupal.org/docs/upgrading-drupal",
			},
			PublishedDate: "2021-11-02",
		})
	}

	return advisories
}

// queryOSVDatabase queries the OSV database for vulnerabilities affecting a specific package
func (matcher PHPFrameworkVulnerabilityMatcher) queryOSVDatabase(
	packageName string,
	frameworkVersion string,
	knowledge *bun.DB,
) ([]FrameworkVulnerabilityMatch, error) {

	matches := []FrameworkVulnerabilityMatch{}

	// Create packageurl for the package
	purl := packageurl.NewPackageURL("composer", "", packageName, "", packageurl.Qualifiers{}, "")

	// Query OSV database including FriendsOfPHP
	osvReports, err := osv.GetAllOSVReportsForPurl(purl.ToString(), knowledge)
	if err != nil {
		return matches, err
	}

	// Convert OSV reports to framework vulnerability matches
	for _, report := range osvReports {
		// Check if the installed version is actually affected by this vulnerability
		isAffected := matcher.isVersionAffectedByOSVReport(frameworkVersion, report)
		if !isAffected {
			continue // Skip vulnerabilities that don't affect the installed version
		}

		// Prepare description with fallback
		details := report.Details
		if details == "" || details == "####." {
			if report.Summary != "" {
				details = report.Summary
			} else {
				details = fmt.Sprintf("Security advisory for %s", packageName)
			}
		}

		match := FrameworkVulnerabilityMatch{
			VulnerabilityID: report.OSVId,
			PackageName:     packageName,
			PackageVersion:  frameworkVersion,
			Source:          "OSV Database",
			Summary:         report.Summary,
			Details:         details,
			PublishedDate:   report.Published,
			ModifiedDate:    report.Modified,
			WithdrawnDate:   report.Withdrawn,
		}

		// Extract CVSS score if available
		if len(report.Severity) > 0 {
			if report.Severity[0].Score != "" {
				// Parse CVSS score from string
				var cvss float64
				fmt.Sscanf(report.Severity[0].Score, "%f", &cvss)
				match.CVSS = cvss
			}
		} else {
			// FriendsOfPHP advisories may not have CVSS scores, assign a default medium severity
			// based on the fact that they are security advisories
			match.CVSS = 5.0 // Medium severity as default for security advisories
		}

		// Extract references
		for _, ref := range report.References {
			match.References = append(match.References, ref.Url)
		}

		// Check if this is from FriendsOfPHP
		if source, exists := report.DatabaseSpecific["source"]; exists {
			if sourceStr, ok := source.(string); ok && sourceStr == "FriendsOfPHP" {
				match.Source = "FriendsOfPHP"
			}
		}

		matches = append(matches, match)
	}

	return matches, nil
}

// queryNVDDatabase queries the NVD database for vulnerabilities affecting a specific product
// with proper version filtering to prevent false positives
func (matcher PHPFrameworkVulnerabilityMatcher) queryNVDDatabase(
	productName string,
	frameworkVersion string,
	knowledge *bun.DB,
) ([]FrameworkVulnerabilityMatch, error) {

	matches := []FrameworkVulnerabilityMatch{}
	ctx := context.Background()

	// Use more precise CPE product matching to avoid false positives
	// Map framework names to their exact CPE product identifiers
	productCPEMap := map[string][]string{
		"laravel":           {"laravel", "laravel_framework"},
		"laravel_framework": {"laravel", "laravel_framework"},
		"symfony":           {"symfony", "symfony_framework"},
		"symfony_framework": {"symfony", "symfony_framework"},
		"wordpress":         {"wordpress"},
		"drupal":            {"drupal"},
		"cakephp":           {"cakephp"},
		"codeigniter":       {"codeigniter"},
		"slim":              {"slim", "slim_framework"},
		"slim_framework":    {"slim", "slim_framework"},
	}

	cpeProducts, exists := productCPEMap[productName]
	if !exists {
		cpeProducts = []string{productName} // fallback to original name
	}

	// Query for exact CPE product matches only, avoiding broad LIKE searches
	var conditions []string
	for _, cpeProduct := range cpeProducts {
		// Match exact product names in CPE strings to avoid false positives
		conditions = append(conditions, fmt.Sprintf(`"affected"::text ~ '"product"\s*:\s*"%s"'`, cpeProduct))
	}

	rows, err := knowledge.QueryContext(ctx, fmt.Sprintf(`
		SELECT DISTINCT "id", "nvd_id", "sourceIdentifier", "vulnStatus", "published", "lastModified", 
		       "descriptions", "affected", "metrics", "weaknesses", "references"
		FROM nvd 
		WHERE (%s)
		LIMIT 100
	`, strings.Join(conditions, " OR ")))

	if err != nil {
		log.Printf("Error querying NVD database for product %s: %v", productName, err)
		return matches, err
	}
	defer rows.Close()

	var nvdVulns []knowledge_db.NVDItem
	err = knowledge.ScanRows(ctx, rows, &nvdVulns)
	if err != nil {
		log.Printf("Error scanning NVD rows: %v", err)
		return matches, err
	}

	// Convert NVD items to framework vulnerability matches with version filtering
	for _, vuln := range nvdVulns {
		// Check if this vulnerability actually affects the installed framework version
		isAffected, confidence := matcher.isVersionAffectedByNVDItem(frameworkVersion, vuln, productName)
		if !isAffected {
			continue // Skip vulnerabilities that don't affect the installed version
		}

		match := FrameworkVulnerabilityMatch{
			VulnerabilityID: vuln.NVDId,
			PackageName:     productName,
			PackageVersion:  frameworkVersion,
			Source:          "NVD Database",
			Summary:         fmt.Sprintf("NVD vulnerability for %s", productName),
			PublishedDate:   vuln.Published,
			ModifiedDate:    vuln.LastModified,
		}

		// Add confidence warning for potential false positives
		if confidence < 1.0 {
			match.Summary = fmt.Sprintf("[POTENTIAL FALSE POSITIVE] %s", match.Summary)
		}

		// Extract description from first available description
		if len(vuln.Descriptions) > 0 {
			match.Details = vuln.Descriptions[0].Value
		}

		// Extract CVSS score - try v3.1, then v3.0, then v2
		if len(vuln.Metrics.CvssMetricV31) > 0 {
			match.CVSS = vuln.Metrics.CvssMetricV31[0].CvssData.BaseScore
		} else if len(vuln.Metrics.CvssMetricV30) > 0 {
			match.CVSS = vuln.Metrics.CvssMetricV30[0].CvssData.BaseScore
		} else if len(vuln.Metrics.CvssMetricV2) > 0 {
			match.CVSS = vuln.Metrics.CvssMetricV2[0].CvssData.BaseScore
		}

		// Add NVD reference
		match.References = []string{fmt.Sprintf("https://nvd.nist.gov/vuln/detail/%s", vuln.NVDId)}

		matches = append(matches, match)
	}

	return matches, nil
}

// isVersionAffectedByOSVReport checks if a version is affected by an OSV vulnerability report
// by parsing the affected version ranges and comparing with the installed version
func (matcher PHPFrameworkVulnerabilityMatcher) isVersionAffectedByOSVReport(
	installedVersion string,
	report knowledge_db.OSVItem,
) bool {
	if installedVersion == "unknown" || installedVersion == "" {
		return true // Assume affected if version is unknown for safety
	}

	// Parse the installed version using Composer semver rules
	installedSemver, err := semverVersionTypes.ParseSemverWithEcosystem(installedVersion, "composer")
	if err != nil {
		log.Printf("Failed to parse installed version %s: %v", installedVersion, err)
		return true // Assume affected if we can't parse the version for safety
	}

	// Check each affected entry in the OSV report
	for _, affected := range report.Affected {
		// Check explicit vulnerable versions list first
		for _, explicitVersion := range affected.Versions {
			if explicitVersion == installedVersion {
				return true // Exact match in vulnerable versions list
			}
		}

		// Check version ranges
		for _, versionRange := range affected.Ranges {
			if matcher.isVersionInRange(installedSemver, versionRange) {
				return true // Version falls within vulnerable range
			}
		}
	}

	return false // Version is not affected
}

// isVersionInRange checks if a version falls within a vulnerable range
func (matcher PHPFrameworkVulnerabilityMatcher) isVersionInRange(
	installedSemver semverVersionTypes.Semver,
	versionRange knowledge_db.Range,
) bool {
	for _, event := range versionRange.Events {
		// Handle "introduced" version - vulnerability starts from this version
		if event.Introduced != "" {
			introducedSemver, err := semverVersionTypes.ParseSemverWithEcosystem(event.Introduced, "composer")
			if err != nil {
				log.Printf("Failed to parse introduced version %s: %v", event.Introduced, err)
				continue
			}

			// Special case: "0" means all versions are affected from the beginning
			if event.Introduced == "0" {
				// Check if there's a "fixed" version
				if event.Fixed != "" {
					fixedSemver, err := semverVersionTypes.ParseSemverWithEcosystem(event.Fixed, "composer")
					if err == nil {
						// Vulnerable if installed version is less than fixed version
						return installedSemver.Compare(fixedSemver, false) < 0
					}
				} else if event.Last_affected != "" {
					lastAffectedSemver, err := semverVersionTypes.ParseSemverWithEcosystem(event.Last_affected, "composer")
					if err == nil {
						// Vulnerable if installed version is less than or equal to last affected
						return installedSemver.Compare(lastAffectedSemver, false) <= 0
					}
				} else {
					// No upper bound, all versions are affected
					return true
				}
			} else {
				// Check if installed version is >= introduced version
				if installedSemver.Compare(introducedSemver, false) >= 0 {
					// Now check for upper bound
					if event.Fixed != "" {
						fixedSemver, err := semverVersionTypes.ParseSemverWithEcosystem(event.Fixed, "composer")
						if err == nil {
							// Vulnerable if installed version is less than fixed version
							return installedSemver.Compare(fixedSemver, false) < 0
						}
					} else if event.Last_affected != "" {
						lastAffectedSemver, err := semverVersionTypes.ParseSemverWithEcosystem(event.Last_affected, "composer")
						if err == nil {
							// Vulnerable if installed version is less than or equal to last affected
							return installedSemver.Compare(lastAffectedSemver, false) <= 0
						}
					} else {
						// No upper bound, vulnerable if >= introduced
						return true
					}
				}
			}
		}
	}

	return false
}

// isVersionAffectedByNVDItem checks if a version is affected by an NVD vulnerability
// Returns (isAffected, confidence) where confidence indicates reliability of the match
func (matcher PHPFrameworkVulnerabilityMatcher) isVersionAffectedByNVDItem(
	installedVersion string,
	nvdItem knowledge_db.NVDItem,
	expectedProductName string,
) (bool, float64) {
	if installedVersion == "unknown" || installedVersion == "" {
		return true, 0.5 // Low confidence for unknown versions
	}

	// Parse the installed version using Composer semver rules
	installedSemver, err := semverVersionTypes.ParseSemverWithEcosystem(installedVersion, "composer")
	if err != nil {
		log.Printf("Failed to parse installed version %s: %v", installedVersion, err)
		return true, 0.3 // Very low confidence if we can't parse the version
	}

	highestConfidence := 0.0
	isAffected := false

	// Check each affected entry in the NVD item
	for _, affected := range nvdItem.Affected {
		for _, source := range affected.Sources {
			// Verify this is for the correct product to avoid false positives
			productMatch := matcher.verifyNVDProductMatch(source.CriteriaDict, expectedProductName)
			if productMatch < 0.5 {
				continue // Skip if product doesn't match well enough
			}

			// Check version ranges
			affected, confidence := matcher.isVersionInNVDRange(installedSemver, source)
			if affected && confidence > highestConfidence {
				isAffected = true
				highestConfidence = confidence * productMatch // Combine product and version confidence
			}
		}
	}

	return isAffected, highestConfidence
}

// verifyNVDProductMatch checks if the NVD CPE entry matches the expected product
// Returns confidence score (0.0 to 1.0)
func (matcher PHPFrameworkVulnerabilityMatcher) verifyNVDProductMatch(
	criteria knowledge_db.CriteriaDict,
	expectedProductName string,
) float64 {
	product := strings.ToLower(criteria.Product)
	vendor := strings.ToLower(criteria.Vendor)
	expected := strings.ToLower(expectedProductName)

	// Exact product match
	if product == expected {
		return 1.0
	}

	// High confidence matches for known mappings
	exactMappings := map[string][]string{
		"laravel":           {"laravel", "laravel_framework"},
		"laravel_framework": {"laravel", "laravel_framework"},
		"symfony":           {"symfony", "symfony_framework"},
		"symfony_framework": {"symfony", "symfony_framework"},
		"wordpress":         {"wordpress"},
		"drupal":            {"drupal"},
		"cakephp":           {"cakephp"},
		"codeigniter":       {"codeigniter"},
		"slim":              {"slim", "slim_framework"},
		"slim_framework":    {"slim", "slim_framework"},
	}

	if validProducts, exists := exactMappings[expected]; exists {
		for _, validProduct := range validProducts {
			if product == validProduct {
				return 0.9 // High confidence for known mappings
			}
		}
	}

	// Check for vendor match combined with similar product name
	if vendor == expected || strings.Contains(vendor, expected) {
		if strings.Contains(product, expected) {
			return 0.7 // Medium-high confidence for vendor + partial product match
		}
		return 0.4 // Lower confidence for vendor match only
	}

	// Avoid false positives from similar but different products
	falsePositivePatterns := []string{
		"laravelcms",       // Not Laravel Framework
		"symfony_demo",     // Demo projects, not the framework
		"wordpress_plugin", // Plugin, not core WordPress
		"drupal_module",    // Module, not core Drupal
	}

	for _, pattern := range falsePositivePatterns {
		if strings.Contains(product, pattern) {
			return 0.0 // Zero confidence for known false positive patterns
		}
	}

	// Partial product name match (lower confidence)
	if strings.Contains(product, expected) {
		return 0.3
	}

	return 0.0 // No match
}

// isVersionInNVDRange checks if a version falls within NVD vulnerability ranges
// Returns (isAffected, confidence)
func (matcher PHPFrameworkVulnerabilityMatcher) isVersionInNVDRange(
	installedSemver semverVersionTypes.Semver,
	source knowledge_db.Sources,
) (bool, float64) {
	// Handle version ranges defined in NVD CPE entries
	hasVersionStart := source.VersionStartIncluding != "" || source.VersionStartExcluding != ""
	hasVersionEnd := source.VersionEndIncluding != "" || source.VersionEndExcluding != ""

	// Check for exact version match first - if this CPE entry has a specific version,
	// only that exact version should be considered affected
	if source.CriteriaDict.Version != "" && source.CriteriaDict.Version != "*" {
		// Parse the CPE version
		cpeVersionSemver, err := semverVersionTypes.ParseSemverWithEcosystem(source.CriteriaDict.Version, "composer")
		if err != nil {
			log.Printf("Failed to parse CPE version %s: %v", source.CriteriaDict.Version, err)
			return false, 0.0 // If we can't parse the CPE version, assume not affected
		}

		// Only affected if installed version exactly matches the CPE version
		isExactMatch := installedSemver.Compare(cpeVersionSemver, false) == 0
		if isExactMatch {
			return true, 1.0 // High confidence for exact version match
		} else {
			return false, 1.0 // High confidence that it's not affected if versions don't match
		}
	}

	// If no version constraints and no specific version, assume all versions (but with low confidence for safety)
	if !hasVersionStart && !hasVersionEnd {
		return true, 0.3 // Low confidence for broad matches to encourage manual review
	}

	// Check start range (including)
	if source.VersionStartIncluding != "" {
		startSemver, err := semverVersionTypes.ParseSemverWithEcosystem(source.VersionStartIncluding, "composer")
		if err != nil {
			log.Printf("Failed to parse start version %s: %v", source.VersionStartIncluding, err)
			return true, 0.3 // Low confidence if we can't parse
		}
		if installedSemver.Compare(startSemver, false) < 0 {
			return false, 1.0 // Not affected, high confidence
		}
	}

	// Check start range (excluding)
	if source.VersionStartExcluding != "" {
		startSemver, err := semverVersionTypes.ParseSemverWithEcosystem(source.VersionStartExcluding, "composer")
		if err != nil {
			log.Printf("Failed to parse start excluding version %s: %v", source.VersionStartExcluding, err)
			return true, 0.3 // Low confidence if we can't parse
		}
		if installedSemver.Compare(startSemver, false) <= 0 {
			return false, 1.0 // Not affected, high confidence
		}
	}

	// Check end range (including) - This is the "Up to (including)" field
	if source.VersionEndIncluding != "" {
		endSemver, err := semverVersionTypes.ParseSemverWithEcosystem(source.VersionEndIncluding, "composer")
		if err != nil {
			log.Printf("Failed to parse end including version %s: %v", source.VersionEndIncluding, err)
			return true, 0.3 // Low confidence if we can't parse
		}
		if installedSemver.Compare(endSemver, false) > 0 {
			return false, 1.0 // Not affected, high confidence
		}
		// If we reach here, installed version is <= end version, so affected
		return true, 0.9 // High confidence for "up to including" matches
	}

	// Check end range (excluding)
	if source.VersionEndExcluding != "" {
		endSemver, err := semverVersionTypes.ParseSemverWithEcosystem(source.VersionEndExcluding, "composer")
		if err != nil {
			log.Printf("Failed to parse end excluding version %s: %v", source.VersionEndExcluding, err)
			return true, 0.3 // Low confidence if we can't parse
		}
		if installedSemver.Compare(endSemver, false) >= 0 {
			return false, 1.0 // Not affected, high confidence
		}
		// If we reach here, installed version is < end version, so affected
		return true, 0.9 // High confidence for "up to excluding" matches
	}

	// If only start range specified and we passed it, assume affected
	if hasVersionStart && !hasVersionEnd {
		return true, 0.8 // Good confidence for open-ended ranges
	}

	return false, 0.5 // Default to not affected with medium confidence
}
