package osv

import (
	packageRepository "github.com/CodeClarityCE/plugin-sca-vuln-finder/src/repository"
	"github.com/CodeClarityCE/plugin-sca-vuln-finder/src/repository/npm"
	vulnerabilityFinder "github.com/CodeClarityCE/plugin-sca-vuln-finder/src/types"
	nodesemver "github.com/CodeClarityCE/utility-node-semver"
	knowledge "github.com/CodeClarityCE/utility-types/knowledge_db"
	"github.com/uptrace/bun"
)

// NormalizeAffectedVersions normalizes the affected versions of a dependency based on the provided OSV reports.
// It takes the dependency name, a list of affected versions, and a package repository as input.
// It returns a list of normalized affected versions.
func NormalizeAffectedVersions(depName string, affectedVersions []knowledge.Affected, packageRepository packageRepository.PackageRepository, knowledge *bun.DB) []vulnerabilityFinder.AffectedVersion {

	normalized := []vulnerabilityFinder.AffectedVersion{}

	for _, affectedItem := range affectedVersions {

		affectedVersion := vulnerabilityFinder.AffectedVersion{}

		// Skip entries that denote vulnerabilities on related products / hardware
		if affectedItem.Package.Name != depName {
			continue
		}

		// Iterate over the affected field in the OSV document and process them

		for _, source := range affectedItem.Ranges {

			affectedRange := vulnerabilityFinder.AffectedRange{}

			for _, event := range source.Events {

				if event.Introduced != "" {
					semverIntro, err := nodesemver.ParseSemver(event.Introduced)
					if err == nil {
						affectedRange.IntroducedSemver = semverIntro
					}
				}
				if event.Fixed != "" {
					semverFixed, err := nodesemver.ParseSemver(event.Fixed)
					if err == nil {
						affectedRange.FixedSemver = semverFixed
					}
				}

				// Future proofing
				// last_affected is part of the osv (open source vulnerability) format specification
				// but I did not find any github advisory using it
				if event.Fixed == "" && event.Last_affected != "" {
					versionAbove, err := npm.GetVersionStringsAbove(depName, event.Last_affected, 1, knowledge)
					if err == nil {
						if len(versionAbove) > 0 {
							semverAbove, err := nodesemver.ParseSemver(versionAbove[0])
							if err == nil {
								affectedRange.FixedSemver = semverAbove
							}
						}
					} else {
						continue
					}
				}

			}

			// In case no "introduced" was defined by the osv report, then that means that all versions
			// up to "fixed" are vulnerable, thus we set the start of the range to the first version of the dependency released
			if affectedRange.IntroducedSemver.String() == "" {
				firstVersion, err := npm.GetFirstVersionString(depName, knowledge)
				if err != nil {
					continue
				}
				semverFirst, err := nodesemver.ParseSemver(firstVersion)
				if err == nil {
					affectedRange.IntroducedSemver = semverFirst
				}
			}

			affectedVersion.Ranges = append(affectedVersion.Ranges, affectedRange)
		}

		normalized = append(normalized, affectedVersion)

	}

	return normalized

}
