package matcher

import (
	"log"
	"slices"
	"strings"

	ecosystemTypes "github.com/CodeClarityCE/plugin-sca-vuln-finder/src/ecosystemAnalyzer/types"
	packageRepository "github.com/CodeClarityCE/plugin-sca-vuln-finder/src/repository"
	"github.com/CodeClarityCE/plugin-sca-vuln-finder/src/repository/cwe"
	vulnerabilityFinderTypes "github.com/CodeClarityCE/plugin-sca-vuln-finder/src/types"
	"github.com/CodeClarityCE/plugin-sca-vuln-finder/src/types/conflict"

	"github.com/uptrace/bun"

	sbomTypes "github.com/CodeClarityCE/plugin-sbom-javascript/src/types/sbom/js"
)

type VulnerabilityMatcher struct {
	ConflictResolver  func(vulnerabilityFinderTypes.Pairs) (conflict.ResolveWinner, conflict.ConflictFlag)
	Ecosystems        []ecosystemTypes.Ecosystem
	PackageRepository packageRepository.PackageRepository
}

func (vm VulnerabilityMatcher) GetWorkspaceVulnerabilities(dependencies map[string]map[string]sbomTypes.Versions, knowledge *bun.DB) []vulnerabilityFinderTypes.Vulnerability {

	owaspTop10CWEListViewIds := []string{
		"1345", "1346", "1347", "1348", "1349", "1352", "1353", "1354", "1355", "1356",
	}

	pairs := vm.findVulnerabilities(dependencies, knowledge)

	return parsePairs(pairs, knowledge, owaspTop10CWEListViewIds)
}

func parsePairs(pairs map[string]map[string]vulnerabilityFinderTypes.Pairs, knowledge *bun.DB, owaspTop10CWEListViewIds []string) []vulnerabilityFinderTypes.Vulnerability {
	vulnerabilities := []vulnerabilityFinderTypes.Vulnerability{}

	// Create deterministic ordering by sorting vulnerability IDs
	vulnIds := make([]string, 0, len(pairs))
	for vulnId := range pairs {
		vulnIds = append(vulnIds, vulnId)
	}
	slices.Sort(vulnIds)

	for _, vuln_id := range vulnIds {
		vuln := pairs[vuln_id]

		// Also sort the dependency keys for deterministic inner loop
		depKeys := make([]string, 0, len(vuln))
		for depKey := range vuln {
			depKeys = append(depKeys, depKey)
		}
		slices.Sort(depKeys)

		for _, depKey := range depKeys {
			conflictData := vuln[depKey]
			name := conflictData.NVD.Dependency.Name
			version := conflictData.NVD.Dependency.Semver.String()
			if name == "" {
				name = conflictData.OSV.Dependency.Name
				version = conflictData.OSV.Dependency.Semver.String()
			}

			vulnerability := vulnerabilityFinderTypes.Vulnerability{
				Sources:            []vulnerabilityFinderTypes.VulnerabilitySource{},
				AffectedDependency: name,
				AffectedVersion:    version,
				VulnerabilityId:    vuln_id,
				OSVMatch:           nil,
				NVDMatch:           nil,
				Severity:           getSeverity(conflictData),
				Weaknesses:         []vulnerabilityFinderTypes.VulnerabilityMatchWeakness{},
				Conflict: vulnerabilityFinderTypes.Conflict{
					ConflictWinner: conflictData.ConflictWinner,
					ConflictFlag:   conflictData.ConflictFlag,
				},
			}

			// Populate sources based on available matches
			if conflictData.OSV.Dependency.Name != "" {
				vulnerability.OSVMatch = &conflictData.OSV

				// Check if this is a FriendsOfPHP vulnerability
				if source, exists := conflictData.OSV.Vulnerability.DatabaseSpecific["source"]; exists {
					if sourceStr, ok := source.(string); ok && sourceStr == "FriendsOfPHP" {
						vulnerability.Sources = append(vulnerability.Sources, vulnerabilityFinderTypes.FriendsOfPHP)
					} else {
						vulnerability.Sources = append(vulnerability.Sources, vulnerabilityFinderTypes.OSV)
					}
				} else {
					vulnerability.Sources = append(vulnerability.Sources, vulnerabilityFinderTypes.OSV)
				}
			}

			if conflictData.NVD.Dependency.Name != "" {
				vulnerability.NVDMatch = &conflictData.NVD
				vulnerability.Sources = append(vulnerability.Sources, vulnerabilityFinderTypes.NVD)
			}

			for _, cwe_id := range conflictData.OSV.Vulnerability.Cwes {
				cweEntry, err := cwe.GetCWE(strings.ReplaceAll(cwe_id, "CWE-", ""), knowledge)
				if err != nil {
					log.Printf("Failed to fetch cwe info: %s", err)
				} else if cweEntry.Categories != nil {
					owaspMappingFound := false
					for _, category := range cweEntry.Categories {
						if slices.Contains(owaspTop10CWEListViewIds, category.ID) {
							vulnerability.Weaknesses = append(vulnerability.Weaknesses, vulnerabilityFinderTypes.VulnerabilityMatchWeakness{
								WeaknessId:     cwe_id,
								OWASPTop10Id:   category.ID,
								OWASPTop10Name: category.Name,
							})
							owaspMappingFound = true
						}
					}
					if !owaspMappingFound {
						vulnerability.Weaknesses = append(vulnerability.Weaknesses, vulnerabilityFinderTypes.VulnerabilityMatchWeakness{
							WeaknessId: cwe_id,
						})
					}
				}
			}

			vulnerabilities = append(vulnerabilities, vulnerability)
		}
	}
	return vulnerabilities
}
