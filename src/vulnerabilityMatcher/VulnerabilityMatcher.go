package matcher

import (
	"log"
	"slices"
	"strings"

	ecosystemTypes "github.com/CodeClarityCE/plugin-sca-vuln-finder/src/ecosystemAnalyzer/types"
	packageRepository "github.com/CodeClarityCE/plugin-sca-vuln-finder/src/repository"
	"github.com/CodeClarityCE/plugin-sca-vuln-finder/src/repository/cwe"
	vulnerabilityFinderTypes "github.com/CodeClarityCE/plugin-sca-vuln-finder/src/types"
	"github.com/CodeClarityCE/plugin-sca-vuln-finder/src/types/conflict"

	"github.com/uptrace/bun"

	sbomTypes "github.com/CodeClarityCE/plugin-sbom-javascript/src/types/sbom/js"
)

type VulnerabilityMatcher struct {
	ConflictResolver  func(vulnerabilityFinderTypes.Pairs) (conflict.ResolveWinner, conflict.ConflictFlag)
	Ecosystems        []ecosystemTypes.Ecosystem
	PackageRepository packageRepository.PackageRepository
}

func (vm VulnerabilityMatcher) GetWorkspaceVulnerabilities(dependencies map[string]map[string]sbomTypes.Versions, knowledge *bun.DB) []vulnerabilityFinderTypes.Vulnerability {

	owaspTop10CWEListViewIds := []string{
		"1345", "1346", "1347", "1348", "1349", "1352", "1353", "1354", "1355", "1356",
	}

	pairs := vm.findVulnerabilities(dependencies, knowledge)

	return parsePairs(pairs, knowledge, owaspTop10CWEListViewIds)
}

func parsePairs(pairs map[string]map[string]vulnerabilityFinderTypes.Pairs, knowledge *bun.DB, owaspTop10CWEListViewIds []string) []vulnerabilityFinderTypes.Vulnerability {
	vulnerabilities := []vulnerabilityFinderTypes.Vulnerability{}
	for vuln_id, vuln := range pairs {
		for _, conflictData := range vuln {
			name := conflictData.NVD.Dependency.Name
			if name == "" {
				name = conflictData.OSV.Dependency.Name
			}

			version := conflictData.NVD.Dependency.Semver.String()
			if version == "" {
				version = conflictData.OSV.Dependency.Semver.String()
			}

			vulnerability := vulnerabilityFinderTypes.Vulnerability{
				Sources:            []vulnerabilityFinderTypes.VulnerabilitySource{},
				AffectedDependency: name,
				AffectedVersion:    version,
				VulnerabilityId:    vuln_id,
				OSVMatch:           nil,
				NVDMatch:           nil,
				Severity:           getSeverity(conflictData),
				Weaknesses:         []vulnerabilityFinderTypes.VulnerabilityMatchWeakness{},
				Conflict: vulnerabilityFinderTypes.Conflict{
					ConflictWinner: conflictData.ConflictWinner,
					ConflictFlag:   conflictData.ConflictFlag,
				},
			}

			if conflictData.OSV.Dependency.Name != "" {
				vulnerability.OSVMatch = &conflictData.OSV
			}

			if conflictData.NVD.Dependency.Name != "" {
				vulnerability.NVDMatch = &conflictData.NVD
			}

			for _, cwe_id := range conflictData.OSV.Vulnerability.Cwes {
				cweEntry, err := cwe.GetCWE(strings.ReplaceAll(cwe_id, "CWE-", ""), knowledge)
				if err != nil {
					log.Printf("Failed to fetch cwe info: %s", err)
				} else if cweEntry.Categories != nil {
					owaspMappingFound := false
					for _, category := range cweEntry.Categories {
						if slices.Contains(owaspTop10CWEListViewIds, category.ID) {
							vulnerability.Weaknesses = append(vulnerability.Weaknesses, vulnerabilityFinderTypes.VulnerabilityMatchWeakness{
								WeaknessId:     cwe_id,
								OWASPTop10Id:   category.ID,
								OWASPTop10Name: category.Name,
							})
							owaspMappingFound = true
						}
					}
					if !owaspMappingFound {
						vulnerability.Weaknesses = append(vulnerability.Weaknesses, vulnerabilityFinderTypes.VulnerabilityMatchWeakness{
							WeaknessId: cwe_id,
						})
					}
				}
			}

			vulnerabilities = append(vulnerabilities, vulnerability)
		}
	}
	return vulnerabilities
}
