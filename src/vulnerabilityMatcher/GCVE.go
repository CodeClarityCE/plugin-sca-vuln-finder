package matcher

import (
	"log"
	"slices"
	"sync"

	sbomTypes "github.com/CodeClarityCE/plugin-sbom-javascript/src/types/sbom/js"
	"github.com/CodeClarityCE/plugin-sca-vuln-finder/src/repository/gcve"
	vulnerabilityFinder "github.com/CodeClarityCE/plugin-sca-vuln-finder/src/types"
	gcveMatcher "github.com/CodeClarityCE/plugin-sca-vuln-finder/src/vulnerabilityMatcher/gcve"
	semver "github.com/CodeClarityCE/utility-node-semver"
	"github.com/uptrace/bun"
)

func (vm VulnerabilityMatcher) GetGCVEVulnerabilities(dependencies map[string]map[string]sbomTypes.Versions, knowledge *bun.DB) []vulnerabilityFinder.GCVEVulnerability {

	gcveMatches := []vulnerabilityFinder.GCVEVulnerability{}

	var wg sync.WaitGroup
	maxGoroutines := 20
	guard := make(chan struct{}, maxGoroutines)
	mutex := sync.Mutex{}
	var errorCount int

	// Create deterministic ordering by sorting dependency names
	dependencyNames := make([]string, 0, len(dependencies))
	for dependencyName := range dependencies {
		dependencyNames = append(dependencyNames, dependencyName)
	}
	slices.Sort(dependencyNames)

	// For each dependency get all GCVE reports matching the product name
	for _, dependency_name := range dependencyNames {
		dependency := dependencies[dependency_name]
		wg.Add(1)
		guard <- struct{}{}
		go func(dep_name string, dep map[string]sbomTypes.Versions, wg *sync.WaitGroup) {
			defer wg.Done()

			// Create deterministic ordering for version names
			versionNames := make([]string, 0, len(dep))
			for versionName := range dep {
				versionNames = append(versionNames, versionName)
			}
			slices.Sort(versionNames)

			for _, version_name := range versionNames {
				version := dep[version_name]

				if !version.Direct && !version.Transitive {
					continue
				}

				vulnerabilities, err := gcve.GetVulnsByProduct(dep_name, knowledge)
				if err != nil {
					mutex.Lock()
					errorCount++
					mutex.Unlock()
					log.Printf("Failed to fetch GCVE reports for dep: %s, error: %v", dep_name, err)
					continue
				}

				// For each report generate "uniform" affected versions for easier post processing
				for _, vulnerability := range vulnerabilities {
					affectedUniform := gcveMatcher.NormalizeAffectedVersions(dep_name, vulnerability.Affected, knowledge)
					semver, err := semver.ParseSemver(version_name)
					if err == nil {
						mutex.Lock()
						gcveMatches = append(gcveMatches, vulnerabilityFinder.GCVEVulnerability{
							Vulnerability: vulnerability,
							Dependency: vulnerabilityFinder.Dependency{
								Name:        dep_name,
								VersionInfo: version,
								Semver:      semver,
							},
							AffectedInfo: affectedUniform,
						})
						mutex.Unlock()
					}
				}
			}
			<-guard
		}(dependency_name, dependency, &wg)
	}
	wg.Wait()

	log.Printf("GCVE vulnerability lookup completed. Processed %d dependencies, %d errors, found %d potential matches",
		len(dependencyNames), errorCount, len(gcveMatches))

	filteredMatches := []vulnerabilityFinder.GCVEVulnerability{}

	// For each match, check if the version of the installed dependency is vulnerable
	for _, gcveMatch := range gcveMatches {
		matches, evidenceVulnerable := MatchRange(gcveMatch.AffectedInfo, gcveMatch.Dependency.Semver)
		if matches {
			gcveMatch.VulnerableEvidenceType = vulnerabilityFinder.VULNERABLE_EVIDENCE_RANGE
			gcveMatch.VulnerableEvidenceRange = evidenceVulnerable
			gcveMatch.Vulnerable = true
			filteredMatches = append(filteredMatches, gcveMatch)
			continue
		}
		matches, evidenceVulnerableExact := MatchExact(gcveMatch.AffectedInfo, gcveMatch.Dependency.Semver)
		if matches {
			gcveMatch.VulnerableEvidenceType = vulnerabilityFinder.VULNERABLE_EVIDENCE_EXACT
			gcveMatch.VulnerableEvidenceExact = evidenceVulnerableExact
			gcveMatch.Vulnerable = true
			filteredMatches = append(filteredMatches, gcveMatch)
			continue
		}
		matches, evidenceVulnerableUniversal := MatchUniversal(gcveMatch.AffectedInfo, gcveMatch.Dependency.Semver)
		if matches {
			gcveMatch.VulnerableEvidenceType = vulnerabilityFinder.VULNERABLE_EVIDENCE_UNIVERSAL
			gcveMatch.VulnerableEvidenceUniversal = evidenceVulnerableUniversal
			gcveMatch.Vulnerable = true
			filteredMatches = append(filteredMatches, gcveMatch)
			continue
		}
	}

	// Return only those matches which affect our installed dependencies
	return filteredMatches
}
