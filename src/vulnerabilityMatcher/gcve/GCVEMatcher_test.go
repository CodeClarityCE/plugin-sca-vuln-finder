package gcve

import (
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestProductMatchesDep(t *testing.T) {
	tests := []struct {
		name     string
		product  string
		vendor   string
		depName  string
		expected bool
	}{
		// Direct matches with meaningful vendor
		{"direct match real vendor", "lodash", "lodash_project", "lodash", true},
		{"direct match case insensitive", "Lodash", "lodash_project", "lodash", true},

		// Direct matches with generic vendor â€” rejected
		{"generic vendor unknown", "clone", "unknown", "clone", false},
		{"generic vendor n/a", "clone", "n/a", "clone", false},
		{"generic vendor empty", "clone", "", "clone", false},

		// PHP vendor/package format
		{"php package match", "console", "symfony", "symfony/console", true},
		{"php package vendor mismatch", "console", "laravel", "symfony/console", false},
		{"php package product mismatch", "http-kernel", "symfony", "symfony/console", false},

		// Scoped npm packages
		{"scoped npm match", "core", "babel", "@babel/core", true},
		{"scoped npm vendor mismatch", "core", "somecompany", "@babel/core", false},
		{"scoped npm product mismatch", "parser", "babel", "@babel/core", false},

		// Underscore/hyphen normalization
		{"hyphen underscore direct", "my_package", "my_vendor", "my-package", true},

		// Completely unrelated
		{"unrelated names", "archiver", "gfi", "express", false},

		// No match at all
		{"different product", "react", "facebook", "angular", false},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := productMatchesDep(tt.product, tt.vendor, tt.depName)
			assert.Equal(t, tt.expected, result, "productMatchesDep(%q, %q, %q)", tt.product, tt.vendor, tt.depName)
		})
	}
}
