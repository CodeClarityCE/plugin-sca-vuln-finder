package gcve

import (
	"strings"

	vulnerabilityFinder "github.com/CodeClarityCE/plugin-sca-vuln-finder/src/types"
	"github.com/CodeClarityCE/plugin-sca-vuln-finder/src/vulnerabilityMatcher/helpers"
	nodesemver "github.com/CodeClarityCE/utility-node-semver"
	knowledge "github.com/CodeClarityCE/utility-types/knowledge_db"
	"github.com/uptrace/bun"
)

// NormalizeAffectedVersions converts GCVE affected entries into the unified
// AffectedVersion format used by the matching engine.
func NormalizeAffectedVersions(depName string, affected []knowledge.GCVEAffected, knowledge *bun.DB) []vulnerabilityFinder.AffectedVersion {
	normalized := []vulnerabilityFinder.AffectedVersion{}

	for _, entry := range affected {
		if !productMatchesDep(entry.Product, entry.Vendor, depName) {
			continue
		}

		affectedVersion := vulnerabilityFinder.AffectedVersion{}

		for _, ver := range entry.Versions {
			if ver.Status != "affected" {
				continue
			}

			if ver.LessThan != "" || ver.LessThanOrEqual != "" {
				// Range-based version matching
				affectedRange := vulnerabilityFinder.AffectedRange{}

				// Parse the fixed/upper-bound version first.
				// If the upper bound is present but unparseable (e.g., "unspecified"),
				// skip this entry entirely rather than creating an open-ended range
				// that would incorrectly match all versions above introduced.
				if ver.LessThan != "" {
					fixed, err := nodesemver.ParseSemver(ver.LessThan)
					if err != nil {
						continue // Skip: upper bound declared but unparseable
					}
					affectedRange.FixedSemver = fixed
				} else if ver.LessThanOrEqual != "" {
					fixed, err := nodesemver.ParseSemver(ver.LessThanOrEqual)
					if err != nil {
						continue // Skip: upper bound declared but unparseable
					}
					affectedRange.FixedSemver = fixed
					// Inclusive upper bound but our matching uses exclusive (introduced <= dep < fixed).
					// Bump patch to include the lessThanOrEqual version itself.
					affectedRange.FixedSemver.Patch++
				}

				// Parse the introduced version
				if ver.Version != "" && ver.Version != "0" {
					introduced, err := nodesemver.ParseSemver(ver.Version)
					if err != nil {
						continue // Skip: introduced version unparseable
					}
					affectedRange.IntroducedSemver = introduced
				}

				affectedVersion.Ranges = append(affectedVersion.Ranges, affectedRange)
			} else {
				// Exact version match
				exactSemver, err := nodesemver.ParseSemver(ver.Version)
				if err == nil {
					affectedVersion.Exact = append(affectedVersion.Exact, vulnerabilityFinder.AffectedExact{
						VersionString: ver.Version,
						VersionSemver: exactSemver,
					})
				}
			}
		}

		// If no versions specified but defaultStatus is "affected", all versions are vulnerable
		if len(entry.Versions) == 0 && entry.DefaultStatus == "affected" {
			affectedVersion.Universal = vulnerabilityFinder.AffectedUniversal{}
		}

		normalized = append(normalized, affectedVersion)
	}

	return normalized
}

// productMatchesDep checks if a CVE product/vendor matches a dependency name.
// CVE records use vendor/product format (like CPE), while SBOM dependencies use
// package names (npm names, composer vendor/package, etc.).
func productMatchesDep(product, vendor, depName string) bool {
	productLower := strings.ToLower(product)
	depLower := strings.ToLower(depName)

	// Direct product name match (for unscoped npm packages like "lodash")
	if productLower == depLower {
		// When vendor is generic (unknown, n/a, empty), the match is ambiguous
		// and very likely a cross-ecosystem collision (e.g., WordPress "Clone"
		// plugin vs npm "clone" package). Require a meaningful vendor.
		if helpers.IsGenericVendor(vendor) {
			return false
		}
		return true
	}

	// For PHP packages (vendor/package format), require both vendor and product to match.
	// This prevents false positives where a generic product name like "console" matches
	// an unrelated package like "symfony/console".
	parts := strings.Split(depLower, "/")
	if len(parts) == 2 && !strings.HasPrefix(depLower, "@") {
		vendorLower := strings.ToLower(vendor)
		normalizedVendor := strings.ReplaceAll(vendorLower, "_", "-")
		normalizedPart0 := strings.ReplaceAll(parts[0], "_", "-")
		normalizedProduct := strings.ReplaceAll(productLower, "_", "-")
		normalizedPart1 := strings.ReplaceAll(parts[1], "_", "-")
		if normalizedVendor == normalizedPart0 && normalizedProduct == normalizedPart1 {
			return true
		}
		return false
	}

	// For scoped npm packages (@scope/name), require scope to match vendor
	// and name to match product. This prevents a GCVE for product "core" by
	// vendor "SomeCompany" from matching "@babel/core".
	if strings.HasPrefix(depLower, "@") {
		scopedParts := strings.SplitN(depLower, "/", 2)
		if len(scopedParts) == 2 {
			vendorLower := strings.ToLower(vendor)
			scope := strings.TrimPrefix(scopedParts[0], "@")
			// Try direct match
			if vendorLower == scope && productLower == scopedParts[1] {
				return true
			}
			// Try underscore/hyphen normalized match
			normalizedVendor := strings.ReplaceAll(vendorLower, "_", "-")
			normalizedScope := strings.ReplaceAll(scope, "_", "-")
			normalizedProduct := strings.ReplaceAll(productLower, "_", "-")
			normalizedName := strings.ReplaceAll(scopedParts[1], "_", "-")
			if normalizedVendor == normalizedScope && normalizedProduct == normalizedName {
				return true
			}
		}
		return false
	}

	// Handle underscores vs hyphens (common in CPE vs package names)
	normalizedProduct := strings.ReplaceAll(productLower, "_", "-")
	normalizedDep := strings.ReplaceAll(depLower, "_", "-")
	if normalizedProduct == normalizedDep {
		// Same generic vendor check as the direct match above
		if helpers.IsGenericVendor(vendor) {
			return false
		}
		return true
	}

	return false
}
