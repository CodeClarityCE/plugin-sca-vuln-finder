package gcve

import (
	"strings"

	vulnerabilityFinder "github.com/CodeClarityCE/plugin-sca-vuln-finder/src/types"
	nodesemver "github.com/CodeClarityCE/utility-node-semver"
	knowledge "github.com/CodeClarityCE/utility-types/knowledge_db"
	"github.com/uptrace/bun"
)

// NormalizeAffectedVersions converts GCVE affected entries into the unified
// AffectedVersion format used by the matching engine.
func NormalizeAffectedVersions(depName string, affected []knowledge.GCVEAffected, knowledge *bun.DB) []vulnerabilityFinder.AffectedVersion {
	normalized := []vulnerabilityFinder.AffectedVersion{}

	for _, entry := range affected {
		if !productMatchesDep(entry.Product, entry.Vendor, depName) {
			continue
		}

		affectedVersion := vulnerabilityFinder.AffectedVersion{}

		for _, ver := range entry.Versions {
			if ver.Status != "affected" {
				continue
			}

			if ver.LessThan != "" || ver.LessThanOrEqual != "" {
				// Range-based version matching
				affectedRange := vulnerabilityFinder.AffectedRange{}

				// Parse the introduced version
				if ver.Version != "" && ver.Version != "0" {
					introduced, err := nodesemver.ParseSemver(ver.Version)
					if err == nil {
						affectedRange.IntroducedSemver = introduced
					}
				}

				// Parse the fixed version
				if ver.LessThan != "" {
					fixed, err := nodesemver.ParseSemver(ver.LessThan)
					if err == nil {
						affectedRange.FixedSemver = fixed
					}
				} else if ver.LessThanOrEqual != "" {
					// LessThanOrEqual means the version is still affected
					// We need the next version as the "fixed" boundary
					// For now, we just use the version directly and rely on inclusive matching
					fixed, err := nodesemver.ParseSemver(ver.LessThanOrEqual)
					if err == nil {
						affectedRange.FixedSemver = fixed
						// NOTE: This is an inclusive upper bound but our matching uses exclusive.
						// The MatchRange function checks: introduced <= dep < fixed
						// For lessThanOrEqual, the version itself is affected.
						// We handle this by bumping the patch version.
						affectedRange.FixedSemver.Patch++
					}
				}

				affectedVersion.Ranges = append(affectedVersion.Ranges, affectedRange)
			} else {
				// Exact version match
				exactSemver, err := nodesemver.ParseSemver(ver.Version)
				if err == nil {
					affectedVersion.Exact = append(affectedVersion.Exact, vulnerabilityFinder.AffectedExact{
						VersionString: ver.Version,
						VersionSemver: exactSemver,
					})
				}
			}
		}

		// If no versions specified but defaultStatus is "affected", all versions are vulnerable
		if len(entry.Versions) == 0 && entry.DefaultStatus == "affected" {
			affectedVersion.Universal = vulnerabilityFinder.AffectedUniversal{}
		}

		normalized = append(normalized, affectedVersion)
	}

	return normalized
}

// productMatchesDep checks if a CVE product/vendor matches a dependency name.
// CVE records use vendor/product format (like CPE), while SBOM dependencies use
// package names (npm names, composer vendor/package, etc.).
func productMatchesDep(product, vendor, depName string) bool {
	productLower := strings.ToLower(product)
	depLower := strings.ToLower(depName)

	// Direct product name match
	if productLower == depLower {
		return true
	}

	// For PHP packages (vendor/package format), try matching the package part
	parts := strings.Split(depLower, "/")
	if len(parts) == 2 {
		// Match against just the package name
		if productLower == parts[1] {
			return true
		}
		// Match vendor/product against vendor/package
		vendorLower := strings.ToLower(vendor)
		if vendorLower == parts[0] && productLower == parts[1] {
			return true
		}
	}

	// For scoped npm packages (@scope/name), try matching just the name
	if strings.HasPrefix(depLower, "@") {
		scopedParts := strings.SplitN(depLower, "/", 2)
		if len(scopedParts) == 2 && productLower == scopedParts[1] {
			return true
		}
	}

	// Handle underscores vs hyphens (common in CPE vs package names)
	normalizedProduct := strings.ReplaceAll(productLower, "_", "-")
	normalizedDep := strings.ReplaceAll(depLower, "_", "-")
	if normalizedProduct == normalizedDep {
		return true
	}

	return false
}
