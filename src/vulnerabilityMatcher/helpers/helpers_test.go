package helpers

import (
	"testing"

	knowledge "github.com/CodeClarityCE/utility-types/knowledge_db"
	"github.com/stretchr/testify/assert"
	"github.com/uptrace/bun"
)

func TestVendorRelatedToProduct(t *testing.T) {
	tests := []struct {
		name     string
		vendor   string
		product  string
		expected bool
	}{
		// Exact matches
		{"wildcard vendor", "*", "anything", true},
		{"identical names", "lodash", "lodash", true},
		{"identical with underscores", "my_lib", "my-lib", true},
		{"case insensitive exact", "LODASH", "lodash", true},

		// Substring matches (both names >= 4 chars)
		{"vendor contains product", "archiver_project", "archiver", true},
		{"product contains vendor", "archiver", "archiver_project", true},
		{"vendor suffix match", "node-glob", "glob", true},

		// Short name protection (< 4 chars) — substring NOT allowed
		{"short product 'a'", "apache", "a", false},
		{"short product 'go'", "google", "go", false},
		{"short product 'tar'", "starlink", "tar", false},
		{"short vendor 'gfi'", "gfi", "archiver", false},
		{"short vendor 'ms'", "ms", "microsoft", false},

		// Exact match still works for short names
		{"short exact match", "tar", "tar", true},
		{"short exact match 2", "go", "go", true},

		// Unrelated names (both long enough)
		{"unrelated long names", "microsoft", "archiver", false},
		{"unrelated vendors", "gfi-software", "archiver", false},

		// Edge cases
		{"empty strings", "", "", true},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := VendorRelatedToProduct(tt.vendor, tt.product)
			assert.Equal(t, tt.expected, result, "VendorRelatedToProduct(%q, %q)", tt.vendor, tt.product)
		})
	}
}

func TestIsGenericVendor(t *testing.T) {
	tests := []struct {
		name     string
		vendor   string
		expected bool
	}{
		{"unknown lowercase", "unknown", true},
		{"Unknown mixed case", "Unknown", true},
		{"UNKNOWN uppercase", "UNKNOWN", true},
		{"n/a lowercase", "n/a", true},
		{"N/A uppercase", "N/A", true},
		{"empty string", "", true},
		{"real vendor", "symfony", false},
		{"real vendor with underscore", "archiver_project", false},
		// "unknown_vendor" normalizes to "unknown-vendor", not "unknown"
		{"unknown_vendor is not generic", "unknown_vendor", false},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := IsGenericVendor(tt.vendor)
			assert.Equal(t, tt.expected, result, "IsGenericVendor(%q)", tt.vendor)
		})
	}
}

func TestAnyBoundaryVersionExists(t *testing.T) {
	mockVersions := func(depName string, db *bun.DB) ([]string, error) {
		return []string{"1.0.0", "1.1.0", "2.0.0", "2.1.0"}, nil
	}

	t.Run("no boundaries returns true", func(t *testing.T) {
		source := knowledge.Sources{} // all version fields empty
		result, _ := AnyBoundaryVersionExists("test-pkg", source, nil, nil, mockVersions)
		assert.True(t, result)
	})

	t.Run("matching start boundary returns true", func(t *testing.T) {
		source := knowledge.Sources{
			VersionStartIncluding: "1.0.0",
			VersionEndExcluding:   "2.0.0",
		}
		result, _ := AnyBoundaryVersionExists("test-pkg", source, nil, nil, mockVersions)
		assert.True(t, result)
	})

	t.Run("matching end boundary returns true", func(t *testing.T) {
		source := knowledge.Sources{
			VersionEndExcluding: "2.0.0",
		}
		result, _ := AnyBoundaryVersionExists("test-pkg", source, nil, nil, mockVersions)
		assert.True(t, result)
	})

	t.Run("non-matching boundaries returns false", func(t *testing.T) {
		source := knowledge.Sources{
			VersionStartIncluding: "3.0.0",
			VersionEndExcluding:   "4.0.0",
		}
		result, _ := AnyBoundaryVersionExists("test-pkg", source, nil, nil, mockVersions)
		assert.False(t, result)
	})

	t.Run("Debian-style version not in npm returns false", func(t *testing.T) {
		source := knowledge.Sources{
			VersionStartIncluding: "1.7.1-5",
			VersionEndExcluding:   "1.7.1-10",
		}
		result, _ := AnyBoundaryVersionExists("test-pkg", source, nil, nil, mockVersions)
		assert.False(t, result)
	})

	t.Run("cached version set is reused", func(t *testing.T) {
		callCount := 0
		countingVersions := func(depName string, db *bun.DB) ([]string, error) {
			callCount++
			return []string{"1.0.0", "2.0.0"}, nil
		}

		source1 := knowledge.Sources{VersionEndExcluding: "1.0.0"}
		result1, versionSet := AnyBoundaryVersionExists("pkg", source1, nil, nil, countingVersions)
		assert.True(t, result1)
		assert.Equal(t, 1, callCount)

		// Second call with cached version set should not call getVersions again
		source2 := knowledge.Sources{VersionEndExcluding: "2.0.0"}
		result2, _ := AnyBoundaryVersionExists("pkg", source2, nil, versionSet, countingVersions)
		assert.True(t, result2)
		assert.Equal(t, 1, callCount) // still 1 — cache was used
	})

	t.Run("error from getVersions returns true conservatively", func(t *testing.T) {
		errorVersions := func(depName string, db *bun.DB) ([]string, error) {
			return nil, assert.AnError
		}
		source := knowledge.Sources{VersionEndExcluding: "1.0.0"}
		result, _ := AnyBoundaryVersionExists("test-pkg", source, nil, nil, errorVersions)
		assert.True(t, result) // assumes valid to avoid false negatives
	})

	t.Run("empty versions returns true conservatively", func(t *testing.T) {
		emptyVersions := func(depName string, db *bun.DB) ([]string, error) {
			return []string{}, nil
		}
		source := knowledge.Sources{VersionEndExcluding: "1.0.0"}
		result, _ := AnyBoundaryVersionExists("test-pkg", source, nil, nil, emptyVersions)
		assert.True(t, result)
	})
}
