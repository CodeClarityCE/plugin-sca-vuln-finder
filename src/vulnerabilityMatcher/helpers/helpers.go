package helpers

import (
	"strings"

	knowledge "github.com/CodeClarityCE/utility-types/knowledge_db"
	"github.com/uptrace/bun"
)

// minSubstringLen is the minimum product/vendor name length for substring matching.
// Names shorter than this require exact match to avoid false positives
// (e.g., "go" matching "google", "a" matching "archiver").
const minSubstringLen = 4

// VendorRelatedToProduct checks whether a CPE vendor is plausibly related to the
// given product name. This filters out cross-ecosystem false positives when
// targetSw is a wildcard (e.g., "gfi" is unrelated to "archiver", but
// "archiver_project" is related to "archiver").
func VendorRelatedToProduct(vendor, product string) bool {
	v := strings.ToLower(strings.ReplaceAll(vendor, "_", "-"))
	p := strings.ToLower(strings.ReplaceAll(product, "_", "-"))
	if v == "*" || v == p {
		return true
	}
	// Only allow substring matching when both names are long enough
	// to avoid false positives with short names like "a", "go", "tar".
	if len(v) >= minSubstringLen && len(p) >= minSubstringLen {
		return strings.Contains(v, p) || strings.Contains(p, v)
	}
	return false
}

// IsGenericVendor checks if a vendor string is a generic/unknown placeholder
// that provides no useful signal for matching.
func IsGenericVendor(vendor string) bool {
	v := strings.ToLower(strings.ReplaceAll(vendor, "_", "-"))
	return v == "unknown" || v == "n/a" || v == ""
}

// AnyBoundaryVersionExists checks if at least one CPE version boundary exists
// as a real published version. The getVersions callback retrieves versions
// for the given package name from the appropriate ecosystem registry.
// If versionSet is non-nil, it is used directly (cache hit); otherwise getVersions
// is called and the resulting set is returned for caching by the caller.
func AnyBoundaryVersionExists(
	depName string,
	source knowledge.Sources,
	db *bun.DB,
	versionSet map[string]bool,
	getVersions func(string, *bun.DB) ([]string, error),
) (bool, map[string]bool) {
	boundaries := []string{
		source.VersionStartIncluding,
		source.VersionStartExcluding,
		source.VersionEndExcluding,
		source.VersionEndIncluding,
	}

	hasBoundary := false
	for _, b := range boundaries {
		if b != "" {
			hasBoundary = true
			break
		}
	}
	if !hasBoundary {
		return true, versionSet // No range boundaries â€” handled elsewhere
	}

	// Build version set on first call, reuse on subsequent calls
	if versionSet == nil {
		versions, err := getVersions(depName, db)
		if err != nil || len(versions) == 0 {
			return true, nil // Can't validate, assume valid to avoid false negatives
		}
		versionSet = make(map[string]bool, len(versions))
		for _, v := range versions {
			versionSet[v] = true
		}
	}

	for _, b := range boundaries {
		if b != "" && versionSet[b] {
			return true, versionSet
		}
	}
	return false, versionSet
}
