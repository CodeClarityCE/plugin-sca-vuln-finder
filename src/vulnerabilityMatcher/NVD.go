package matcher

import (
	"log"
	"strings"
	"sync"

	"github.com/CodeClarityCE/plugin-sca-vuln-finder/src/repository/nvd"
	vulnerabilityFinder "github.com/CodeClarityCE/plugin-sca-vuln-finder/src/types"
	semver "github.com/CodeClarityCE/utility-node-semver"
	"github.com/uptrace/bun"

	sbomTypes "github.com/CodeClarityCE/plugin-sbom-javascript/src/types/sbom/js"
	nvdMatcher "github.com/CodeClarityCE/plugin-sca-vuln-finder/src/vulnerabilityMatcher/nvd"
)

func (vm VulnerabilityMatcher) GetNVDVulnerabilities(dependencies map[string]map[string]sbomTypes.Versions, knowledge *bun.DB) []vulnerabilityFinder.NVDVulnerability {

	nvdMatches := []vulnerabilityFinder.NVDVulnerability{}

	var wg sync.WaitGroup
	maxGoroutines := 20
	guard := make(chan struct{}, maxGoroutines)
	mutex := sync.Mutex{}

	// For each dependency get all reports in the nvd with the same "product" name and type "application"
	for dependency_name, dependency := range dependencies {
		wg.Add(1)
		guard <- struct{}{}
		go func(wg *sync.WaitGroup) {
			defer wg.Done()
			for version_name, version := range dependency {

				if !version.Direct && !version.Transitive {
					continue
				}

				vulnerabilities, err := nvd.GetVulnsByDepName(dependency_name, knowledge)
				if err != nil {
					log.Println("Failed to fetch nvd reports for dep: " + dependency_name)
					continue
				}

				// For each report generate "uniform" affected versions for easier post processing
				for _, vulnerability := range vulnerabilities {
					var affectedUniform []vulnerabilityFinder.AffectedVersion
					// Detect if this is a PHP package and use appropriate CPE matcher
					if isPHPPackage(dependency_name) {
						affectedUniform = nvdMatcher.NormalizeAffectedVersionsPHP(dependency_name, vulnerability.Affected, knowledge)
					} else {
						affectedUniform = nvdMatcher.NormalizeAffectedVersions(dependency_name, vulnerability.Affected, knowledge)
					}
					semver, err := semver.ParseSemver(version_name)
					if err == nil {
						mutex.Lock()
						nvdMatches = append(nvdMatches, vulnerabilityFinder.NVDVulnerability{
							Vulnerability: vulnerability,
							Dependency: vulnerabilityFinder.Dependency{
								Name:        dependency_name,
								VersionInfo: version,
								Semver:      semver,
							},
							AffectedInfo: affectedUniform,
						})
						mutex.Unlock()
					}
				}
			}
			<-guard
		}(&wg)
	}
	wg.Wait()

	filteredMatches := []vulnerabilityFinder.NVDVulnerability{}

	// For each match, check if the version of the installed dependency is vulnerable according
	// to the NVD report
	for _, nvdMatch := range nvdMatches {
		matches, evidenceVulnerable := MatchRange(nvdMatch.AffectedInfo, nvdMatch.Dependency.Semver)
		if matches {
			nvdMatch.VulnerableEvidenceType = vulnerabilityFinder.VULNERABLE_EVIDENCE_RANGE
			nvdMatch.VulnerableEvidenceRange = evidenceVulnerable
			nvdMatch.Vulnerable = true
			filteredMatches = append(filteredMatches, nvdMatch)
			continue
		}
		matches, evidenceVulnerableExact := MatchExact(nvdMatch.AffectedInfo, nvdMatch.Dependency.Semver)
		if matches {
			nvdMatch.VulnerableEvidenceType = vulnerabilityFinder.VULNERABLE_EVIDENCE_EXACT
			nvdMatch.VulnerableEvidenceExact = evidenceVulnerableExact
			nvdMatch.Vulnerable = true
			filteredMatches = append(filteredMatches, nvdMatch)
			continue
		}
		matches, evidenceVulnerableUniversal := MatchUniversal(nvdMatch.AffectedInfo, nvdMatch.Dependency.Semver)
		if matches {
			nvdMatch.VulnerableEvidenceType = vulnerabilityFinder.VULNERABLE_EVIDENCE_UNIVERSAL
			nvdMatch.VulnerableEvidenceUniversal = evidenceVulnerableUniversal
			nvdMatch.Vulnerable = true
			filteredMatches = append(filteredMatches, nvdMatch)
			continue
		}

	}

	// Return only those matches which affect our installed dependencies
	return filteredMatches

}

// isPHPPackage detects if a package name follows PHP/Composer naming conventions
// PHP packages always use the vendor/package format (e.g., "symfony/console", "laravel/framework")
// This distinguishes them from JavaScript packages which use different naming patterns
func isPHPPackage(packageName string) bool {
	// PHP packages must contain exactly one slash and have both vendor and package parts
	parts := strings.Split(packageName, "/")
	if len(parts) != 2 {
		return false
	}

	// Both vendor and package name must be non-empty
	if parts[0] == "" || parts[1] == "" {
		return false
	}

	// PHP packages don't use @ scoping like npm packages
	if strings.Contains(packageName, "@") {
		return false
	}

	return true
}
