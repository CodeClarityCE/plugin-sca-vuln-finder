package nvd

import (
	"slices"

	"github.com/CodeClarityCE/plugin-sca-vuln-finder/src/repository/npm"
	vulnerabilityFinder "github.com/CodeClarityCE/plugin-sca-vuln-finder/src/types"
	nodesemver "github.com/CodeClarityCE/utility-node-semver"

	knowledge "github.com/CodeClarityCE/utility-types/knowledge_db"
	"github.com/uptrace/bun"
)

func NormalizeAffectedVersions(depName string, affectedVersions []knowledge.NVDAffected, knowledge *bun.DB) []vulnerabilityFinder.AffectedVersion {

	normalized := []vulnerabilityFinder.AffectedVersion{}

	for _, affectedItem := range affectedVersions {

		affectedVersion := vulnerabilityFinder.AffectedVersion{}

		for _, source := range affectedItem.Sources {

			// Skip CPE entries that denote vulnerabilities on related products / hardware
			// Skip CPE entries that denote non-vulnerable versions
			JS_target_software := []string{"node.js", "*"}
			if source.CriteriaDict.Product != depName || !source.Vulnerable || !slices.Contains(JS_target_software, source.CriteriaDict.TargetSw) {
				continue
			}

			affectedRange := vulnerabilityFinder.AffectedRange{}
			affectedRange.CPEInfo = source

			// NVD reports can detail the vulnerabile versions via ranges or "exact" versions
			//
			// Range example:
			//    VersionStartIncluding: 2.5.5
			//    VersionEndExcluding: 5.0.0
			//
			// Exact example:
			//    cpe:2.3:a:hbs_project:hbs:4.3.3:*:*:*:*:node.js:*:*
			//                              |-> 4.3.3 is vulnerable of hbs
			if source.VersionStartIncluding == "" && source.VersionStartExcluding == "" &&
				source.VersionEndExcluding == "" && source.VersionEndIncluding == "" {
				affectedVersion = parseExact(source, affectedVersion)
			} else {
				affectedVersion = parseRange(source, affectedRange, affectedVersion, depName, knowledge)

			}

		}

		normalized = append(normalized, affectedVersion)

	}

	return normalized

}

// parseRange processes the affected version ranges from the NVD report and adds them to the AffectedRange object.
// It expects the following parameters:
// - source: the NVD report source containing the version range information
// - affectedRange: a pointer to the AffectedRange object where the version range will be added
// - affectedVersion: a pointer to the AffectedVersion object where the version range will be added
// - packageName: the name of the package/library being analyzed
//
// The affected version ranges in the NVD report are denoted by 4 keywords:
// - versionStartIncluding: the version at which the vulnerability was introduced in this range
// - versionStartExcluding: the last non-affected version before the start of the vulnerable range
// - versionEndExcluding: the first fixed version after the vulnerable range
// - versionEndIncluding: the last affected version of this range
//
// This function processes these keywords accordingly and adds the version range to the AffectedRange object.
// The AffectedRange object expects "introduced" and "fixed" versions, which correspond to versionStartIncluding
// and versionEndExcluding respectively in the NVD report.
//
// If versionStartExcluding is provided, it is processed to get the version one below to denote "introduced".
// If versionEndIncluding is provided, it is processed to get the version one above to denote "fixed".
//
// If no "introduced" version is defined in the NVD report, it means that all versions up to the "fixed" version
// are vulnerable. In this case, the start of the range is set to the first version of the dependency released.
//
// If there is no version above the "fixed" version and no "introduced" version, it means that every version of
// the library is vulnerable. In this case, the affectedVersion object is set to universal vulnerability.
//
// If any error occurs during the parsing or retrieval of version information, the function returns without
// adding the version range to the affected objects.
func parseRange(source knowledge.Sources, affectedRange vulnerabilityFinder.AffectedRange, affectedVersion vulnerabilityFinder.AffectedVersion, packageName string, knowledge *bun.DB) vulnerabilityFinder.AffectedVersion {

	// NVD denotes their affected version ranges via 4 keywords
	// versionStartIncluding -> at which version the vulnerability was introduced in this range
	// versionStartExcluding -> the last non-affected version before the start of the vulnerable range
	// versionEndExcluding -> the first fixed version after the vulnerable range
	// versionEndIncluding -> the last affected version of this range
	//
	// Process them accordingly and add them to the AffectedRange object
	//
	// Our unfied AffectedRange object expects "introduced" and "fixed" , which correspond
	// to versionStartIncluding and versionEndExcluding respectively in NVD
	//
	// versionStartExcluding has to be processed to get the version one below so as to denote "introduced"
	// versionEndIncluding has to be processed to get the version one above so as to denote "fixed"

	// Process the "introduction" version of the vulnerability
	if source.VersionStartIncluding != "" {
		semverStart, err := nodesemver.ParseSemver(source.VersionStartIncluding)
		if err == nil {
			affectedRange.IntroducedSemver = semverStart
		}
	} else if source.VersionStartExcluding != "" {
		versionBelow, err := npm.GetVersionStringsBelow(packageName, source.VersionStartExcluding, 1, knowledge)
		if err == nil {
			if len(versionBelow) > 0 {
				semverBelow, err := nodesemver.ParseSemver(versionBelow[0])
				if err == nil {
					affectedRange.IntroducedSemver = semverBelow
				}
			} else {
				return affectedVersion
			}
		} else {
			return affectedVersion
		}
	}

	// Process the "patched" version of the vulnerability (if any)
	if source.VersionEndExcluding != "" {
		semverEnd, err := nodesemver.ParseSemver(source.VersionEndExcluding)
		if err == nil {
			affectedRange.FixedSemver = semverEnd
		}
	} else if source.VersionEndIncluding != "" {
		versionAbove, err := npm.GetVersionStringsAbove(packageName, source.VersionEndIncluding, 1, knowledge)
		if err == nil {
			if len(versionAbove) > 0 {
				semverAbove, err := nodesemver.ParseSemver(versionAbove[0])
				if err == nil {
					affectedRange.FixedSemver = semverAbove
				}
			} else {
				// In case there exists no version above and no introduced
				// then that means that every version of the library is vulnerable.
				//
				// Example: CVE-2017-16113
				// no version above 0.0.3 exists and the nvd reports says versionEndIncluding = 0.0.3
				// This is the same as saying every version is vulnerable
				//
				// https://github.com/github/advisory-database/blob/b07a1c25e2ec4fe59bf3dae2c6b7db3b02f4ae75/advisories/github-reviewed/2018/07/GHSA-q75g-2496-mxpp/GHSA-q75g-2496-mxpp.json
				// https://nvd.nist.gov/vuln/detail/CVE-2017-16113
				// https://registry.npmjs.cf/parsejson
				affectedVersion.Universal = vulnerabilityFinder.AffectedUniversal{CPEInfo: source}
			}
		} else {
			return affectedVersion
		}
	}

	// In case no "introduced" was defined by the nvd report, then that means that all versions
	// up to "fixed" are vulnerable, thus we set the start of the range to the first version of the dependency released
	if affectedRange.IntroducedSemver.String() == "" {
		firstVersion, err := npm.GetFirstVersionString(packageName, knowledge)
		if err != nil {
			return affectedVersion
		}
		semverFirst, err := nodesemver.ParseSemver(firstVersion)
		if err == nil {
			affectedRange.IntroducedSemver = semverFirst
		}
	}
	affectedVersion.Ranges = append(affectedVersion.Ranges, affectedRange)
	return affectedVersion
}

// parseExact parses the exact version information from the given NVD report source and updates the affectedVersion object accordingly.
// In NVD reports, there are multiple ways to denote vulnerable library versions, including using "ranges" and CPEs.
// This function specifically handles the case where an exact version is specified in the CPE specification.
// If the exact version is "*", "-", or "ANY", it sets the affectedVersion to universal.
// Otherwise, it parses the exact version using the nodesemver library and adds it to the affectedVersion object.
func parseExact(source knowledge.Sources, affectedVersion vulnerabilityFinder.AffectedVersion) vulnerabilityFinder.AffectedVersion {
	// In NVD reports, unlike Github Advisory reports, not only uses "ranges" to denote vulnerable library versions
	// In NVD there are two additional ways, through using CPEs.
	//
	//  In the version part of the CPE specification one can either specify an exact version of "ANY"/"-"/"*"
	//
	//  cpe:2.3:a:hbs_project:hbs:4.3.3:*:*:*:*:node.js:*:*
	//                            |-> 4.3.3 is vulnerable of hbs
	//
	//  cpe:2.3:a:hbs_project:hbs:*:*:*:*:*:node.js:*:*
	//                            |-> Any version is vulnerable of hbs
	//  Equivalent to:
	//  cpe:2.3:a:hbs_project:hbs:-:*:*:*:*:node.js:*:*
	//                            |-> Any version is vulnerable of hbs
	//  Equivalent to:
	//  cpe:2.3:a:hbs_project:hbs:ANY:*:*:*:*:node.js:*:*
	//                            |-> Any version is vulnerable of hbs
	//
	//
	//  Often the CPEs are used to denote many exact versions:
	//  cpe:2.3:a:hbs_project:hbs:4.3.2:*:*:*:*:node.js:*:*
	//                            |-> 4.3.2 is vulnerable of hbs
	//  cpe:2.3:a:hbs_project:hbs:4.3.3:*:*:*:*:node.js:*:*
	//                            |-> 4.3.3 is vulnerable of hbs
	//  cpe:2.3:a:hbs_project:hbs:5.7.3:*:*:*:*:node.js:*:*
	//                            |-> 5.7.3 is vulnerable of hbs
	exact := source.CriteriaDict.Version

	if exact != "" {
		if exact == "*" || exact == "-" || exact == "ANY" {
			affectedVersion.Universal = vulnerabilityFinder.AffectedUniversal{CPEInfo: source}
		} else {
			semverExact, err := nodesemver.ParseSemver(exact)
			if err == nil {
				affectedVersion.Exact = append(affectedVersion.Exact, vulnerabilityFinder.AffectedExact{
					VersionString: exact,
					VersionSemver: semverExact,
					CPEInfo:       source,
				})
			}
		}

	}

	return affectedVersion
}
