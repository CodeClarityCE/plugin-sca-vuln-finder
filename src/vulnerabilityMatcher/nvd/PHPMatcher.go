package nvd

import (
	"slices"

	"github.com/CodeClarityCE/plugin-sca-vuln-finder/src/repository/php"
	vulnerabilityFinder "github.com/CodeClarityCE/plugin-sca-vuln-finder/src/types"
	semver "github.com/CodeClarityCE/utility-node-semver"

	knowledge "github.com/CodeClarityCE/utility-types/knowledge_db"
	"github.com/uptrace/bun"
)

func NormalizeAffectedVersionsPHP(depName string, affectedVersions []knowledge.NVDAffected, knowledge *bun.DB) []vulnerabilityFinder.AffectedVersion {

	normalized := []vulnerabilityFinder.AffectedVersion{}

	for _, affectedItem := range affectedVersions {

		affectedVersion := vulnerabilityFinder.AffectedVersion{}

		for _, source := range affectedItem.Sources {

			// Skip CPE entries that denote vulnerabilities on related products / hardware
			// Skip CPE entries that denote non-vulnerable versions
			// PHP packages can have target_sw as "php", "*", or sometimes empty
			PHP_target_software := []string{"php", "*", ""}
			if source.CriteriaDict.Product != depName || !source.Vulnerable || !slices.Contains(PHP_target_software, source.CriteriaDict.TargetSw) {
				continue
			}

			affectedRange := vulnerabilityFinder.AffectedRange{}
			affectedRange.CPEInfo = source

			// NVD reports can detail the vulnerable versions via ranges or "exact" versions
			//
			// Range example:
			//    VersionStartIncluding: 2.5.5
			//    VersionEndExcluding: 5.0.0
			//
			// Exact example:
			//    cpe:2.3:a:vendor:package:4.3.3:*:*:*:*:php:*:*
			//                              |-> 4.3.3 is vulnerable version
			if source.VersionStartIncluding == "" && source.VersionStartExcluding == "" &&
				source.VersionEndExcluding == "" && source.VersionEndIncluding == "" {
				affectedVersion = parseExactPHP(source, affectedVersion)
			} else {
				affectedVersion = parseRangePHP(source, affectedRange, affectedVersion, depName, knowledge)
			}

		}

		normalized = append(normalized, affectedVersion)

	}

	return normalized

}

// parseRangePHP processes the affected version ranges from the NVD report for PHP packages
// Similar to the JavaScript version but uses Composer semantic versioning rules
func parseRangePHP(source knowledge.Sources, affectedRange vulnerabilityFinder.AffectedRange, affectedVersion vulnerabilityFinder.AffectedVersion, packageName string, knowledge *bun.DB) vulnerabilityFinder.AffectedVersion {

	// Process the "introduction" version of the vulnerability
	if source.VersionStartIncluding != "" {
		semverStart, err := semver.ParseSemverWithEcosystem(source.VersionStartIncluding, semver.Composer)
		if err == nil {
			affectedRange.IntroducedSemver = semverStart
		}
	} else if source.VersionStartExcluding != "" {
		versionBelow, err := php.GetVersionStringsBelow(packageName, source.VersionStartExcluding, 1, knowledge)
		if err == nil {
			if len(versionBelow) > 0 {
				semverBelow, err := semver.ParseSemverWithEcosystem(versionBelow[0], semver.Composer)
				if err == nil {
					affectedRange.IntroducedSemver = semverBelow
				}
			} else {
				return affectedVersion
			}
		} else {
			return affectedVersion
		}
	}

	// Process the "patched" version of the vulnerability (if any)
	if source.VersionEndExcluding != "" {
		semverEnd, err := semver.ParseSemverWithEcosystem(source.VersionEndExcluding, semver.Composer)
		if err == nil {
			affectedRange.FixedSemver = semverEnd
		}
	} else if source.VersionEndIncluding != "" {
		versionAbove, err := php.GetVersionStringsAbove(packageName, source.VersionEndIncluding, 1, knowledge)
		if err == nil {
			if len(versionAbove) > 0 {
				semverAbove, err := semver.ParseSemverWithEcosystem(versionAbove[0], semver.Composer)
				if err == nil {
					affectedRange.FixedSemver = semverAbove
				}
			} else {
				// Every version is vulnerable if no version above exists
				affectedVersion.Universal = vulnerabilityFinder.AffectedUniversal{CPEInfo: source}
			}
		} else {
			return affectedVersion
		}
	}

	// In case no "introduced" was defined, set the start to the first version of the dependency
	if affectedRange.IntroducedSemver.String() == "" {
		firstVersion, err := php.GetFirstVersionString(packageName, knowledge)
		if err != nil {
			return affectedVersion
		}
		semverFirst, err := semver.ParseSemverWithEcosystem(firstVersion, semver.Composer)
		if err == nil {
			affectedRange.IntroducedSemver = semverFirst
		}
	}
	affectedVersion.Ranges = append(affectedVersion.Ranges, affectedRange)
	return affectedVersion
}

// parseExactPHP parses exact PHP package versions from CPE specifications
func parseExactPHP(source knowledge.Sources, affectedVersion vulnerabilityFinder.AffectedVersion) vulnerabilityFinder.AffectedVersion {
	// Handle exact versions in CPE for PHP packages
	//  cpe:2.3:a:vendor:package:1.2.3:*:*:*:*:php:*:*
	//                            |-> 1.2.3 is vulnerable version
	//
	//  cpe:2.3:a:vendor:package:*:*:*:*:*:php:*:*
	//                            |-> Any version is vulnerable
	exact := source.CriteriaDict.Version

	if exact != "" {
		if exact == "*" || exact == "-" || exact == "ANY" {
			affectedVersion.Universal = vulnerabilityFinder.AffectedUniversal{CPEInfo: source}
		} else {
			semverExact, err := semver.ParseSemverWithEcosystem(exact, semver.Composer)
			if err == nil {
				affectedVersion.Exact = append(affectedVersion.Exact, vulnerabilityFinder.AffectedExact{
					VersionString: exact,
					VersionSemver: semverExact,
					CPEInfo:       source,
				})
			}
		}
	}

	return affectedVersion
}
